---
title: "Week 2: Interpolation"
subtitle: "W2S2: Splines"
format:
  live-revealjs:
    slide-number: true
    brand: ../_brand.yml
    theme: ../hevs.scss
    show-slide-number: all
    preview-links: auto
    chalkboard: true
    logo: https://www.hevs.ch/_nuxt/img/logo_hesso.9af1d79.svg
    footer: "W2S2 - Splines"
    include-in-header: ../_includes/revealscript.html
    include-after-body: ../_includes/backbutton.html
    
execute:
  echo: true       # ← this shows code
  output: true     # ← this shows output
  eval: true       # ← this runs the code
---


## Splines vs Global Interpolation

**Global polynomial interpolation**

- Single high-degree polynomial through all points
- Pros: closed form; Cons: global coupling & oscillations (Runge)

**Splines (piecewise polynomials)**

- Low-degree pieces joined at **knots**
- **Local effect**: editing one point mainly affects neighbors
- Continuity at knots: $C^0$ (value), $C^1$ (slope), $C^2$ (curvature)

---

> ::: callout-tip
**Highlight:** Splines trade a global high-degree fit for local, stable pieces.
:::


## Linear & Quadratic Splines

**Linear spline**

- Piecewise lines; $C^0$ only; fast, robust, no overshoot; corners at knots

**Quadratic spline**

- Piecewise quadratics; can achieve $C^1$; needs boundary info or extra conditions
- Smoother than linear; still local and stable

> ::: callout-note
**Highlight:** Quadratic adds slope continuity vs. linear.
:::


## Cubic / Natural Cubic Splines

**Cubic spline**

- Piecewise cubics with $C^2$ continuity; common practical choice

**Natural:** $f''=0$ at ends

**Why popular**

- Smooth, stable, local: avoids high-degree oscillations


## B-Splines (Control-Point Curves)

**Idea**

- Curve = sum of **B-spline basis** × **control points** (with a knot vector)
- Usually **do not interpolate** data; they *follow* control polygon
- **Local support** (move one control point → local change)

> ::: callout-tip
**Highlight:** Think “shape by control points,” not “hit every point.”
:::


## ND Splines & \(t\)-Parameterization

**Parametric curve**
$\mathbf r(t)=(x(t),y(t),z(t),\ldots)$: handles loops/overhangs (works in 2D/3D/ND)

**Choosing $t$ matters**

- Uniform will be our default, but $t$ sampling will affect the Splines.

> ::: callout-tip
Will be used in our lab.
:::


## SciPy: `splprep` / `splev` (Parametric B-Splines)

**Workflow**

1. `splprep([x, y, ...], u=..., s=..., k=...)`: fit smoothing spline, returns `(tck, u)`  
2. `splev(u_new, tck)`: evaluate coordinates at new params

**Key knobs**

- `u`: parameterization (e.g. "time" $t$)
- `s`: smoothing (0 = interpolate; larger = smoother)
- `k`: order (1–5; often 3 = cubic)

## Example

```{pyodide}
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import splprep, splev

# Generate noisy circular data
theta = np.linspace(0, 2*np.pi, 30, endpoint=False)
x = np.cos(theta) + 0.1 * np.random.default_rng(42).normal(size=theta.size)
y = np.sin(theta) + 0.1 * np.random.default_rng(42).normal(size=theta.size)

# Fit parametric B-spline 
(tck, u) = splprep([x, y], s=0.3, k=3)

# Evaluate spline at fine resolution
u_fine = np.linspace(0, 1, 400)
x_s, y_s = splev(u_fine, tck)

# Plot results
plt.figure(figsize=(6,6))
plt.plot(x, y, 'o', label='Noisy data')
plt.plot(x_s, y_s, 'k-', lw=2, label='B-spline (s=0.3)')
plt.axis('equal')
plt.title("Smoothing Closed Curve with SciPy splprep/splev")
plt.legend()
plt.grid(True)
plt.show()
```

